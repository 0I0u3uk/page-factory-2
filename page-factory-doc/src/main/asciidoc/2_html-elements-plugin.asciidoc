== HTML Plugin
Инструмент, позволяющий реализовать автоматизацию на проекте с использованием типизированных элементов и блоков. Он представляет из себя `web plugin`, расширенный возможностями библиотеки `htmlelements-java` и дополненный логикой взаимодействия с блоками и типизированными элементами.

=== Как начать использовать
Для начала использования необходимо подключить зависимость, указав актуальную версию плагина

[source,]
----
    <dependency>
      <groupId>ru.sbtqa.tag.pagefactory</groupId>
      <artifactId>html-plugin</artifactId>
      <version>Актуальная версия</version>
      <type>jar</type>
    </dependency>
----

Чтобы пользоваться всеми преимуществами плагина, необходимо унаследовать каждую страницу вашего проекта от `HTMLPage`

=== Инициализация элементов страницы
Инициализировать элементы страницы не нужно, так как этот функционал уже зафиксирован на странице-родителе - `HTMLPage`

Если же такая необходимость возникла, то достаточно определить конструктор страницы, вызвав в нем родительский конструктор с нужным декоратором.

Например:


[source,]
----
import org.openqa.selenium.support.pagefactory.FieldDecorator;
import ru.sbtqa.tag.pagefactory.annotations.PageEntry;ы
import ru.sbtqa.tag.pagefactory.environment.Environment;
import ru.sbtqa.tag.pagefactory.HTMLPage;
import ru.yandex.qatools.htmlelements.loader.decorator.HtmlElementDecorator;
import ru.yandex.qatools.htmlelements.loader.decorator.HtmlElementLocatorFactory;

@PageEntry(title = "Ваша страница")
public abstract class YourPage extends HTMLPage {

    public YourPage() {
        super(new HtmlElementDecorator(new HtmlElementLocatorFactory(Environment.getDriverService().getDriver())));
    }
}
----

TIP: Рекомендуется заводить в проекте базовую страницу, унаследованную от `HTMLPage`, и уже от нее наследовать все остальные. Это позволит в случае необходимости описать ряд действий на базовой странице проекта.


=== Блоки и элементы
Для работы с элементами в плагине используется фреймворк  `htmlelements-java`. Он позволяет описывать элементы на странице свойственными им типами (Button, TextIntup, CheckBox и пр.) и группировать эти элементы в блоки. Подробнее об этом можно узнать из документации на данный фреймворк. 

`Html plugin` расширяет функциональные возможности `htmlelements-java` в части работы с комбинированием элементов в блоках

Остановимся на этом подробнее.

Предположим, что у нас есть несколько одинаковых групп элементов. Рассмотрим на примере элементов со страницы яндекс маркета

image::images/blocks.png[]

Каждый товар имеет одинаковое описание - цена, название, категория товара и визуальное представление товара. + 
На странице таких товаров может быть очень много и при необходимости взаимодействия с ними придется объявлять много однотипных элементов, в которых просто запутаться. Чтобы таких ситуаций не возникало, проще считать каждый товар - одним элементом страницы - блоком, содержащим в себе элементы описания товара.

Для примера блок будет выглядеть следующим образом:


[source,]
----
import org.openqa.selenium.support.FindBy;
import ru.sbtqa.tag.pagefactory.annotations.ElementTitle;
import ru.yandex.qatools.htmlelements.element.Image;
import ru.yandex.qatools.htmlelements.element.HtmlElement;
import ru.yandex.qatools.htmlelements.element.TextBlock;
import ru.yandex.qatools.htmlelements.element.Link;

public class Product extends HtmlElement {

    @ElementTitle("Изображение товара")
    @FindBy(xpath = ".//img")
    private Image image;


    @ElementTitle("Стоимость")
    @FindBy(xpath = ".//span[text()]")
    private TextBlock cost;

    @ElementTitle("Наименование")
    @FindBy(xpath = ".//div[starts-with(@class,’name’)]")
    private Link name;

    @ElementTitle("Категория")
    @FindBy(xpath = ".//div[text() and not(starts-with(@class,'name'))]")
    private TextBlock category;
}
----
TIP: Обратите внимание, что все пути внутри блока должны быть относительными (начинаться с точки), иначе поиск элемента не будет выполняться в контексте блока

Яндекс элементы предполагают работу с блоком через его именование в классе-блоке и указанием там же пути до него через соответствующие аннотации @Name и @Block, но в контексте `Html plugin` - это не нужно и накладывает ряд функциональных ограничений. Например, нельзя объявить два одинаковых блока на странице. + 
Поэтому правильнее будет объявлять блоки как и любые другие элементы, задавая им имя и путь через аннотации `@ElementTitle` и `@FindBy` соответственно.

Пример для описанного выше блока:


[source,]
----
import org.openqa.selenium.support.FindBy;
import ru.sbtqa.tag.pagefactory.HTMLPage;
import ru.sbtqa.tag.pagefactory.annotations.ElementTitle;

@PageEntry(title = "Продукты маркета")
public class ProductPage extends HTMLPage {

    @ElementTitle("Наушники")
    @FindBy(xpath = "(//div[@data-zone-name='product'])[1]")
    private Product headphones;

    @ElementTitle("Телефон")
    @FindBy(xpath = "(//div[@data-zone-name='product'])[2]")
    private Product phone;
}
----

КАК РАБОТАТЬ С ЭТИМ?? (Доработать после рефакторинга)

=== Глагольные выражения в блоках
В блоке можно определить глагольные выражения аналогично определению на страницах. Эти выражения будут работать только в контексте блока и только с его элементами

Например, давайте определим проверку категории товара в ранее созданном блоке


[source,]
----
import org.junit.Assert;
import org.openqa.selenium.support.FindBy;
import ru.sbtqa.tag.pagefactory.annotations.ActionTitle;
import ru.sbtqa.tag.pagefactory.annotations.ElementTitle;
import ru.yandex.qatools.htmlelements.element.Image;
import ru.yandex.qatools.htmlelements.element.HtmlElement;
import ru.yandex.qatools.htmlelements.element.TextBlock;
import ru.yandex.qatools.htmlelements.element.Link;

public class Product extends HtmlElement {

    @ElementTitle("Изображение товара")
    @FindBy(xpath = ".//img")
    private Image image;


    @ElementTitle("Стоимость")
    @FindBy(xpath = ".//span[text()]")
    private TextBlock cost;

    @ElementTitle("Наименование")
    @FindBy(xpath = ".//div[starts-with(@class,’name’)]")
    private Link name;

    @ElementTitle("Категория")
    @FindBy(xpath = ".//div[text() and not(starts-with(@class,'name'))]")
    private TextBlock category;

    @ActionTitle("проверяет категорию товара")
    public void checkCategory(String expectedCategory){
        Assert.assertEquals(“Категория товара не соответствует ожидаемой”, expectedCategory, category.getText());
    }
}
----

Выполнить такое глагольное выражение можно следующим образом (для блока с наушниками) 

[source,]
----
 * в блоке "Наушники" (проверяет категорию товара) с параметром "Наушники и Bluetooth-гарнитуры"
----

=== Шаги работы с блоками

Помимо описанного выше шага выполнения глагольного выражения в блоке есть и другие. Ниже приведен полный список шагов.

NOTE: Здесь можно перед шагом использовать “пользователь” или “он”

[source,]
----
# выполнить глагольное выражение без параметров
* в блоке "Имя блока или путь до него" (глагольное выражение в блоке)
# с одним парметром
* в блоке "Имя блока или путь до него" (глагольное выражение в блоке) с параметром "Параметр"
# с параметрами в виде таблицы 
* в блоке "Имя блока или путь до него" (глагольное выражение в блоке) с параметрами из таблицы
    | Значение | Значение |
    | Значение | Значение |

# с двумя и более параметрами
* в блоке "Имя блока или путь до него" (глагольное выражение в блоке) с параметрами "Параметр 1" “Параметр 2” …
----

Так же есть набор проверки наличия шагов в блоке с учетом типа

[source,]
----
# шаги поиска элемента с учетом типа
* в блоке "Имя блока или путь до него" находит элемент "Элемент"
* в блоке "Имя блока или путь до него" находит текстовое поле "Элемент" 
* в блоке "Имя блока или путь до него" находит чекбокс "Элемент" 
* в блоке "Имя блока или путь до него" находит радиокнопка "Элемент"  
* в блоке "Имя блока или путь до него" находит ссылку "Элемент"  
* в блоке "Имя блока или путь до него" находит таблицу "Элемент"  
* в блоке "Имя блока или путь до него" находит заголовок "Элемент"  
* в блоке "Имя блока или путь до него" находит кнопку "Элемент"  
* в блоке "Имя блока или путь до него" находит изображение "Элемент"
----

[source,]
----
   * в списке "" находит элемент со значением "" 
----

=== Методы для работы с элементами

`Html plugin` предоставляет ряд методов для работы с блоками и типизированными элементами

Обратиться к ним можно через `Environment.getReflection()`


[width="100%",options="header"]
|====================
| **Метод** | **Описание**
| boolean isChildOf(Class<?> parent, Field field)
| Получает тип поля и проверяет, что он является дочерним для переданного типа


| <T extends WebElement> T findElementInBlockByTitle(Page page, String blockPath, String title, Class<T> type)
| Находит элемент на заданной странице требуемого типа в указанном блоке. 
В качестве блока можно указать непосредственно имя блока или путь до него, если он находится во вложенной структуре блоков.
Путь задается через разделитель “->”

Обратите внимание, что в случае, если разделитель присутствует в имени блока, то имя будет воспринято как два следом идущих блока.

Если элемент не найден, или найден, но с не соответствующим типом, то будет выброшено исключение


| <T extends WebElement> List<T> findListOfElements(String listTitle, Class<T> type, Object context)
| Находит список элементов требуемого типа в заданном контексте в указанном блоке. 

Если список элементов не найден, или найден, но с не соответствующим типом, то будет выброшено исключение


| HtmlElement findBlock(Page page, String blockPath)
| Выполняет поиск блока по имени или пути на переданной странице.

В качестве блока можно указать непосредственно имя блока или путь до него, если он находится во вложенной структуре блоков.
Путь задается через разделитель “->”

Обратите внимание, что в случае, если разделитель присутствует в имени блока, то имя будет воспринято как два следом идущих блока.

Если блок не найден, то будет выброшено исключение


| List<HtmlElement> findBlocks(Page page, String blockPath)
| Выполняет поиск списка блоков по имени или пути на переданной странице.

В качестве списка блоков можно указать непосредственно имя списка блоков или путь до него, если он находится во вложенной структуре блоков.
Путь задается через разделитель “->”

Обратите внимание, что в случае, если разделитель присутствует в имени списка блоков, то имя будет воспринято как два следом идущих блока.

Если блок не найден, то будет выброшено исключение


| void executeMethodByTitleInBlock(Page page, String block, String actionTitle)
| Выполняет глагольное выражение в указанном блоке с заданной страницы.  

В качестве списка блоков можно указать непосредственно имя списка блоков или путь до него, если он находится во вложенной структуре блоков.
Путь задается через разделитель “->”


| void executeMethodByTitleInBlock(Page page, String blockPath, String actionTitle, Object... parameters)
| Выполняет глагольное выражение с параметрами в указанном блоке с заданной страницы.  

В качестве списка блоков можно указать непосредственно имя списка блоков или путь до него, если он находится во вложенной структуре блоков.
Путь задается через разделитель “->”


| <T extends TypifiedElement> T getTypifiedElementByTitle(Page page, String title)
| Выполняет поиск типизированного элемента по имени на заданной странице


| <T> T getElementByField(Object parentObject, Field field)
| Возвращает элемент поля
|====================
